<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" href="https://raw.githubusercontent.com/Expatish/Expatish.github.io/refs/heads/main/img/newfavicon.ico" type="image/x-icon">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Expatish Dashboard</title>
 <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      display: flex;
    }

    #treeContainer {
      width: 400px;
      border-right: 1px solid #ccc;
      padding-right: 10px;
      margin-right: 20px;
    }

    .frame {
      border: 1px solid #ccc;
      border-radius: 5px;
      margin-bottom: 10px;
      padding: 10px;
      cursor: pointer;
      background-color: #f9f9f9;
      position: relative;
      transition: background-color 0.3s ease;
    }

    .frame:hover {
      background-color: #e9e9e9;
    }

    .subTree {
      margin-top: 10px;
      display: none;
    }

    .subTree.active {
      display: block;
    }

    .paymentDetails {
      display: none;
      margin-top: 10px;
    }

    ul {
      list-style-type: none;
      padding-left: 20px;
    }

    li {
      margin: 5px 0;
    }

    #pendingPaymentsContainer {
    margin-bottom: 10;
    width: 100%;
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 5px;
    background-color: #f9f9f9;
    font-size: 16px;
    cursor: pointer;
    text-align: left;
}

#pendingPaymentsButton {
    width: 100%;
    background-color: rgba(255, 255, 255, 0);
    border: none;
    padding: 10px;
    font-size: 16px;
    cursor: pointer;
    text-align: left;
}

#pendingPaymentsButton:focus {
    outline: none;
}

#pendingPaymentsContent {
    margin-top: 5;
    padding: 10px;
    border-bottom: 1px solid #ccc;
    display: none;
}

.pendingPaymentItem {
    border: 1px solid #ccc;
    padding: 10px;
    margin-bottom: 2.5px;
    border-radius: 5px;
    background-color: #ffffff;
}

    #formContainer {
      width: 300px;
      padding: 20px;
      border: 1px solid #ccc;
      border-radius: 5px;
      background-color: #f9f9f9;
    }

    #formContainer label {
      font-weight: bold;
    }

    #formContainer input {
      width: 100%;
      padding: 8px;
      margin: 8px 0;
      border: 1px solid #ccc;
      border-radius: 5px;
    }

    #formContainer button {
      top: 5px;
      right: 5px;
      padding: 5px 10px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      z-index: 10;
    }

    #formContainer button:hover {
      background-color: #45a049;
    }

    .configureProperties {
      display: none;
      width: 300px;
      padding: 20px;
      border: 1px solid #ccc;
      border-radius: 5px;
      background-color: #f9f9f9;
    }

    .configureProperties input {
      width: 100%;
      padding: 8px;
      margin: 8px 0;
      border: 1px solid #ccc;
      border-radius: 5px;
    }

    .configureButton {
      position: absolute;
      top: 5px;
      right: 5px;
      padding: 5px 10px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      z-index: 10;
    }

    .configureButton:hover {
      background-color: #45a049;
    }

    #tokenModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    #tokenModalContent {
      background: #fff;
      padding: 20px;
      border-radius: 5px;
      text-align: center;
      width: 300px;
    }

    #tokenModal input {
      width: 100%;
      padding: 8px;
      margin-bottom: 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
    }

    #tokenModal button {
      padding: 10px 20px;
      background-color: #4CAF50;
      color: #fff;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }

    #tokenModal button:hover {
      background-color: #45a049;
    }

    #revenuebutton {
      margin-top: 10px;
      background-color: #4CAF50;
      color: #fff;
      border: none;
      cursor: pointer;
      padding: 10px;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <!-- Token Modal -->
  <div id="tokenModal">
    <div id="tokenModalContent">
      <h3>Enter Your Token</h3>
      <input type="password" id="tokenInput" placeholder="Enter token here">
      <button id="tokenSubmitButton">Submit</button>
    </div>
  </div>

  <div id="modalContainer" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); justify-content: center; align-items: center; z-index: 1000;">
    <div style="background: white; padding: 20px; border-radius: 5px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); width: 300px; text-align: center;">
        <h3>Revenue Information</h3>
        <p id="currentRevenue">Current revenue: Loading...</p>
        <p id="estimatedRevenue">Estimated revenue: Loading...</p>
        <button id="closeModalButton" style="background-color: #4CAF50; color: #fff; border: none; cursor: pointer; padding: 10px; border-radius: 5px;">Close</button>
    </div>
</div>

  <div id="treeContainer">
    <!-- <div id="pendingPaymentsContainer"> -->
      <button id="pendingPaymentsContainer">Pending Payments
      </button>
      <div id="pendingPaymentsContent" style="display: none;">
        <div id="pendingPaymentsList">
            <!-- Fetched pending payments will be displayed here -->
        </div>
    </div>
    <!-- </div> -->
  </div>
  <!-- Form container for title, description, category, image -->
  <div id="formContainer">
    <h3>Add New Event</h3>
    <label for="title">Title:</label>
    <input type="text" id="title" name="title" placeholder="Event Title">

    <label for="description">Description:</label>
    <input type="text" id="description" name="description" placeholder="Event Description">

    <label for="category">Category:</label>
    <input type="text" id="category" name="category" placeholder="Event Category">

    <label for="image">Image URL:</label>
    <input type="text" id="image" name="image" placeholder="Image URL">

    <button id="addButton">Add</button>
  </div>

  <div id="formContainer">
    <h3>Add New SubEvent</h3>
    
    <label for="title">Title:</label>
    <input type="text" id="subtitle" name="title" placeholder="Sub-Event Title">

    <label for="description">Description:</label>
    <input type="text" id="subdescription" name="description" placeholder="Sub-Event Description">

    <label for="date">Date:</label>
    <input type="text" id="date" name="date" placeholder="Sub-Event Date">

    <label for="startTime">Start Time:</label>
    <input type="text" id="startTime" name="startTime" placeholder="Start Time">

    <label for="endTime">End Time:</label>
    <input type="text" id="endTime" name="endTime" placeholder="End Time">

    <label for="originalPrice">Original Price:</label>
    <input type="text" id="originalPrice" name="originalPrice" placeholder="Original Price">

    <label for="price">Price:</label>
    <input type="text" id="price" name="price" placeholder="Price">

    <label for="status">Status:</label>
    <input type="text" id="status" name="status" placeholder="Status">

    <label for="stock">Stock:</label>
    <input type="text" id="stock" name="stock" placeholder="Stock">

    <button id="addSubEventButton">Add</button>
</div>


  <!-- Configure Properties Frame -->
  <div class="configureProperties" id="configureProperties">
    <h3>Configure Properties</h3>
    <!-- The form fields will be dynamically injected here -->
    <div id="configFields"></div>

    <button id="saveConfigButton">Save</button>
    <button id="DeleteButton">Delete</button>
  </div>

  <script>
        let state = {
            local: '',
            current: '',
            token: '',
        };

        const setState = (newState) => {
            state = { ...state, ...newState };
        };

// Function to get a cookie value by its name
function getCookie(name) {
    const value = `; ${document.cookie}`;
    const parts = value.split(`; ${name}=`);
    if (parts.length === 2) return parts.pop().split(';').shift();
    return null;
}

// Function to set a cookie
function setCookie(name, value, days) {
    const expires = new Date();
    expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000)); // Set expiration time
    document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/`;
}

// Check if the cookie exists on page load
window.onload = () => {
    const token = getCookie('authToken'); // Check if the 'authToken' cookie exists
    if (token) {
        // If the token cookie exists, set it in the state and initialize the app
        document.getElementById('tokenModal').style.display = 'none';
        setState({ token: token });
        init(); // Initialize the app with the token
    } else {
        // If the token cookie does not exist, show the modal to input the token
        //document.getElementById('tokenModal').style.display = 'block';
    }
};

// Handle the token submission from the modal
document.getElementById('tokenSubmitButton').addEventListener('click', () => {
    const tokenInput = document.getElementById('tokenInput').value.trim();
    if (tokenInput) {
        // Set the token in the state and save it as a cookie
        setState({ token: tokenInput });
        setCookie('authToken', tokenInput, 31); // Save the token in a cookie for 7 days
        document.getElementById('tokenModal').style.display = 'none'; // Hide the modal
        init(); // Initialize the app after the token is set
    } else {
        alert('Please enter a valid token.');
    }
});

    async function refreshPage() {
  try {
    // Fetch updated data
    const events = await fetchData('Events');
    
    // Update state
    //console.log(events)
    setState({ local: events });
    console.log('refreshed state')
  } catch (error) {
    console.error('Failed to refresh page:', error);
  }
}

    // Fetch data from the backend
    async function fetchData(endpoint) {
      const response = await fetch(`https://stripebackend-production-0a48.up.railway.app/read-data/${endpoint}`, {
          headers: {
            Authorization: `Bearer ${state.token}`, // Use the token in the request header
          },
        });
      if (!response.ok) {
        throw new Error(`Failed to load data from ${endpoint}`);
      }
      return await response.json();
    }

    // Convert Firestore timestamp to readable format
    function convertTimestamp(timestamp) {
      const date = new Date(timestamp._seconds * 1000); // Convert seconds to milliseconds
      return date.toLocaleString(); // Returns a readable date format (localized)
    }

    // Recursive function to process nested events and attach payments
    function createEventTree(events,paymentsByEvent, parentElement) {
      //console.log(state.local)
      const ul = document.createElement('ul');
      parentElement.appendChild(ul);
      //console.log(events)

      events.forEach(event => {
        const eventFrame = document.createElement('div');
        eventFrame.classList.add('frame');
        eventFrame.innerText = event.id || event._id;

        // Create Configure Button
        const configureButton = document.createElement('button');
        configureButton.innerText = 'Configure';
        configureButton.classList.add('configureButton');
        eventFrame.appendChild(configureButton);

        // Event listener for Configure button
        configureButton.addEventListener('click', (eventv2) => {
            // Get the innerText of the eventFrame and remove 'Configure'
  let eventFrameText = eventFrame.innerText;
  eventFrameText = eventFrameText.replace('Configure', '').trim(); // Remove 'Configure' and trim any extra spaces

  //console.log('Cleaned eventFrameText:', eventFrameText);

  // Loop through the state.local array to find a match
  for (let i = 0; i < state.local.length; i++) {
    //console.log('Checking state.local[', i, ']:', state.local[i].id);
    //console.log('eventFrameText:', eventFrameText);

    // Check the main event's id first
    if (state.local[i].id === eventFrameText) {
      setState({ current: state.local[i] });
      console.log('Selected Element', state.current.id);
      //return; // Exit the loop if a match is found
    }

    // Now check in the subcollections
    const subcollections = state.local[i].subcollections['->']; // Get the subcollections array
    if (subcollections && subcollections.length > 0) {
      for (let j = 0; j < subcollections.length; j++) {
        //console.log('Checking subcollection[', j, ']:', subcollections[j].id);

        // Check if any subcollection id matches the eventFrameText
        if (subcollections[j].id === eventFrameText) {
          setState({ current: subcollections[j] });
          console.log('Selected Element', state.current.id);
          //return; // Exit the loop if a match is found
        }
      }
    }
  }

          // Determine which properties to show based on whether it's a main event or sub-event
          eventv2.stopPropagation();
          const configFields = document.getElementById('configFields');
          configFields.innerHTML = ''; // Clear previous fields
          //console.log('updating fields')

          if (event.category && event.imageUrl) {
            // This is a sub-event, show sub-event properties
            createMainEventConfigFields(configFields, event);
          } else {
            // This is a main event, show main event properties
            createSubEventConfigFields(configFields, event);

          }

          // Show the Configure Properties frame
          document.getElementById('configureProperties').style.display = 'block';
        });
                    
        // Sub-tree for this event
        const eventSubTree = document.createElement('div');
        eventSubTree.classList.add('subTree');

        // Attach payments related to this event
        const paymentsForEvent = paymentsByEvent[event.id] || [];
        paymentsForEvent.forEach(payment => {
          const paymentFrame = document.createElement('div');
          paymentFrame.classList.add('frame');
          paymentFrame.innerText = `OrderID: ${payment.orderid} - ${payment.name}`;

          const paymentDetails = document.createElement('div');
          paymentDetails.classList.add('paymentDetails');

          const paymentList = document.createElement('ul');
          Object.entries(payment).forEach(([key, value]) => {
            // Skip 'subcollections'
            if (key === 'subcollections') return;

            // Check if the key is 'created' and convert the timestamp to a readable format
            if (key === 'created' && value._seconds && value._nanoseconds) {
              const readableTimestamp = convertTimestamp(value);
              const detailLi = document.createElement('li');
              detailLi.innerText = `${key}: ${readableTimestamp}`;
              paymentList.appendChild(detailLi);
            } else {
              // Normal behavior for other keys
              const detailLi = document.createElement('li');
              detailLi.innerText = `${key}: ${value}`;
              paymentList.appendChild(detailLi);
            }
          });

          paymentDetails.appendChild(paymentList);
          paymentFrame.appendChild(paymentDetails);

          // Add event listener to toggle visibility of payment details on click
          paymentFrame.addEventListener('click', () => {
            paymentDetails.classList.toggle('paymentDetails'); // Toggle visibility of details
          });

          eventSubTree.appendChild(paymentFrame);
        });

        // Recursively process sub-events
    if (event.subcollections && event.subcollections['->']) {
          createEventTree(event.subcollections['->'], paymentsByEvent, eventSubTree);
        }


eventFrame.addEventListener('click', () => {
  eventSubTree.classList.toggle('active');
});


        ul.appendChild(eventFrame);
        ul.appendChild(eventSubTree);
      });
    }

    // Create main event config fields
    function createMainEventConfigFields(configFields, event) {
      //console.log(state.current)
      configFields.innerHTML = `
        <label for="configTitle">Title:</label>
        <input type="text" id="configTitle" name="configTitle" value="${state.current.title || ''}" placeholder="Event Title">
        
        <label for="configDescription">Description:</label>
        <input type="text" id="configDescription" name="configDescription" value="${state.current.text || ''}" placeholder="Event Description">

        <label for="configCategory">Category:</label>
        <input type="text" id="configCategory" name="configCategory" value="${state.current.category || ''}" placeholder="Event Category">

        <label for="configImage">Image URL:</label>
        <input type="text" id="configImage" name="configImage" value="${state.current.imageUrl || ''}" placeholder="Image URL">
      `;
    }

    // Create sub-event config fields
    function createSubEventConfigFields(configFields, event) {
        //console.log(state.current.id)
      configFields.innerHTML = `
        <label for="configTitle">Title:</label>
        <input type="text" id="configTitle" name="configTitle" value="${state.current.title || ''}" placeholder="Sub-Event Title">
        
        <label for="configDescription">Description:</label>
        <input type="text" id="configDescription" name="configDescription" value="${state.current.text || ''}" placeholder="Sub-Event Description">

        <label for="configDate">Date:</label>
        <input type="text" id="configDate" name="configDate" value="${state.current.date || ''}" placeholder="Sub-Event Date">

        <label for="configStartTime">Start Time:</label>
        <input type="text" id="configStartTime" name="configStartTime" value="${state.current.start || ''}" placeholder="Start Time">

        <label for="configEndTime">End Time:</label>
        <input type="text" id="configEndTime" name="configEndTime" value="${state.current.end || ''}" placeholder="End Time">

        <label for="configOriginalPrice">Original Price:</label>
        <input type="text" id="configOriginalPrice" name="configOriginalPrice" value="${state.current.originalprice || ''}" placeholder="Original Price">

        <label for="configPrice">Price:</label>
        <input type="text" id="configPrice" name="configPrice" value="${state.current.price || ''}" placeholder="Price">

        <label for="configStatus">Status:</label>
        <input type="text" id="configStatus" name="configStatus" value="${state.current.status || ''}" placeholder="Status">

        <label for="configStock">Stock:</label>
        <input type="text" id="configStock" name="configStock" value="${state.current.stock || ''}" placeholder="Stock">
      `;
    }


document.getElementById('saveConfigButton').addEventListener('click', async () => {
    const documentId = state.current.id; // Fetch dynamically from a data attribute
    const pricecheck = state.current.price

    if (!documentId) {
        alert("Document ID not found. Please select an event to configure.");
        return;
    }

    if (pricecheck){
      console.log('sub event')
      const subEventId = state.current.id
      const documentId = state.current._id
      const updates = {
        title: document.getElementById('configTitle').value,
        text: document.getElementById('configDescription').value,
        date: document.getElementById('configDate').value,
        start: document.getElementById('configStartTime').value,
        end: document.getElementById('configEndTime').value,
        originalprice: document.getElementById('configOriginalPrice').value,
        price: document.getElementById('configPrice').value,
        status: document.getElementById('configStatus').value,
        stock: document.getElementById('configStock').value,
    };

    try {
      //console.log({ documentId, subEventId, updates })
      const response = await fetch('https://stripebackend-production-0a48.up.railway.app/update-sub-event', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${state.token}`
    },
    body: JSON.stringify({ documentId, subEventId, updates }),
});

        const result = await response.json();
        if (response.ok) {
          await refreshPage();
            alert('Properties updated successfully!');
            // document.getElementById('configTitle').value = 'lol'
            // console.log(document.getElementById('configTitle').value)
            
        } else {
            alert(`Error: ${result.error}`);
        }
    } catch (error) {
        console.error('Error saving configuration:', error);
        alert('An error occurred. Please try again.');
    }
    }

    if (!pricecheck){
      console.log('main event')
      const updates = {
        title: document.getElementById('configTitle').value,
        text: document.getElementById('configDescription').value,
        category: document.getElementById('configCategory').value,
        imageUrl: document.getElementById('configImage').value,
    };

    try {
        const response = await fetch('https://stripebackend-production-0a48.up.railway.app/update-main-event', {
            method: 'POST',
            headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${state.token}` // Replace 'token' with your actual token variable
    },
            body: JSON.stringify({ documentId, updates }),
        });
        

        const result = await response.json();
        if (response.ok) {
          await refreshPage();
            alert('Properties updated successfully!');
            
        } else {
            alert(`Error: ${result.error}`);
        }
    } catch (error) {
        console.error('Error saving configuration:', error);
        alert('An error occurred. Please try again.');
    }

    }
});

//delete button func
document.getElementById('DeleteButton').addEventListener('click', async () => {
    const documentId = state.current.id; // Fetch dynamically from a data attribute
    const pricecheck = state.current.price

    if (!documentId) {
        alert("Document ID not found. Please select an event to delete.");
        return;
    }

    if (pricecheck){
      console.log('sub event')
      const subDocumentId = state.current.id
      const mainDocumentId = state.current._id

    try {
      const response = await fetch('https://stripebackend-production-0a48.up.railway.app/delete-subcollection', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${state.token}`
    },
    body: JSON.stringify({ mainDocumentId, subDocumentId }),
});

        const result = await response.json();
        if (response.ok) {
          await refreshPage();
            alert('Deleted subcollection successfully!');
            
        } else {
            alert(`Error: ${result.error}`);
        }
    } catch (error) {
        console.error('Error deleting subcollection:', error);
        alert('An error occurred. Please try again.');
    }
    }

    if (!pricecheck){
      console.log('main event')

    try {
        const response = await fetch('https://stripebackend-production-0a48.up.railway.app/delete-collection', {
            method: 'POST',
            headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${state.token}` // Replace 'token' with your actual token variable
    },
            body: JSON.stringify({ documentId}),
        });
        

        const result = await response.json();
        if (response.ok) {
          await refreshPage();
            alert('Deleted collection successfully!');
            
        } else {
            alert(`Error: ${result.error}`);
        }
    } catch (error) {
        console.error('Error deleting collection:', error);
        alert('An error occurred. Please try again.');
    }

    }
});

//Add button func
document.getElementById('addButton').addEventListener('click', async (e) => {
  e.preventDefault(); // Prevent default form submission behavior

// Collect values from form fields
const eventtitle = document.getElementById('title').value.trim();
const eventdescription = document.getElementById('description').value.trim();
const eventcategory = document.getElementById('category').value.trim();
const eventimage = document.getElementById('image').value.trim();

// Validate inputs (optional)
if (!eventtitle) {
    alert('Please fill in all required fields.');
    return;
}

// Create the data payload
const newEvent = {
  category: eventcategory,
  title : eventtitle,
  text: eventdescription,
  imageUrl : eventimage,
};

// Send request to the server
fetch('https://stripebackend-production-0a48.up.railway.app/add-main-event', {
    method: 'POST', // HTTP method
    headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${state.token}`
    },
    body: JSON.stringify(newEvent), // Convert the data to a JSON string
})
    .then(response => {
        if (!response.ok) {
            throw new Error(`Error: ${response.statusText}`);
        }
        return response.json();
    })
    .then(data => {
        alert('Event added successfully!');
        console.log('Server response:', data);
        location.reload();

        // Optionally, update UI or refresh events list
        //addEventToLocalState(newEvent);
    })
    .catch(error => {
        console.error('Error adding event:', error);
        alert('Failed to add event. Please try again.');
    });
})

//Addsubevent button func
document.getElementById('addSubEventButton').addEventListener('click', async (e) => {
  e.preventDefault(); // Prevent default form submission behavior

    // Collect values from input fields
    const subEventData = {
        mainEventId: state.current.id,
        title: document.getElementById('subtitle').value.trim(),
        text: document.getElementById('subdescription').value.trim(),
        date: document.getElementById('date').value.trim(),
        start: document.getElementById('startTime').value.trim(),
        end: document.getElementById('endTime').value.trim(),
        originalprice: document.getElementById('originalPrice').value.trim(),
        price: document.getElementById('price').value.trim(),
        status: document.getElementById('status').value.trim(),
        stock: document.getElementById('stock').value.trim(),
    };

    // Validate required fields
    if (!subEventData.title || !subEventData.date) {
        alert('Please fill in the required fields (Title and Date).');
        return;
    }


// Send request to the server
fetch('https://stripebackend-production-0a48.up.railway.app/add-sub-event', {
    method: 'POST', // HTTP method
    headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${state.token}`
    },
    body: JSON.stringify(subEventData), // Convert the data to a JSON string
})
    .then(response => {
        if (!response.ok) {
            throw new Error(`Error: ${response.statusText}`);
        }
        return response.json();
    })
    .then(data => {
        alert('SubEvent added successfully!');
        console.log('Server response:', data);

        // Optionally, update UI or refresh events list
        //addEventToLocalState(newEvent);
    })
    .catch(error => {
        console.error('Error adding Subevent:', error);
        alert('Failed to add Subevent. Please try again.');
    });
})


//Pending payment
const pendingpaymentcontainer = document.getElementById("pendingPaymentsContainer")
const revenuebutton = document.createElement("button");
revenuebutton.textContent = "Revenue";
revenuebutton.style.backgroundColor = "#4CAF50"
revenuebutton.style.color = "#fff"
revenuebutton.style.border = 'none'
revenuebutton.style.cursor = 'pointer'
revenuebutton.style.padding = '5px'
revenuebutton.style.borderRadius = '5px'
revenuebutton.style.float = 'right';
revenuebutton.style.zIndex = 10
pendingpaymentcontainer.appendChild(revenuebutton);

// Modal elements
const modalContainer = document.getElementById("modalContainer");
const closeModalButton = document.getElementById("closeModalButton");
const currentRevenueText = document.getElementById("currentRevenue");
const estimatedRevenueText = document.getElementById("estimatedRevenue");

revenuebutton.addEventListener("click", async (event) => {
    event.stopPropagation(); // Prevent parent container's click event

    // Show the modal
    modalContainer.style.display = "flex";

    // Fetch revenue data from the API
    currentRevenueText.textContent = "Current revenue: Loading...";
    estimatedRevenueText.textContent = "Estimated revenue: Loading...";
    try {
        const response = await fetch("https://stripebackend-production-0a48.up.railway.app/get-revenue", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                'Authorization': `Bearer ${state.token}`
            },
        });

        if (!response.ok) {
            throw new Error(`API Error: ${response.statusText}`);
        }

        const { currentRevenue, estimatedRevenue } = await response.json();

        // Update modal content with fetched data
        currentRevenueText.textContent = `Current revenue: $${currentRevenue || 0}`;
        estimatedRevenueText.textContent = `Estimated revenue: $${estimatedRevenue || 0}`;
    } catch (error) {
        console.error("Error fetching revenue data:", error);
        currentRevenueText.textContent = "Current revenue: Error loading data.";
        estimatedRevenueText.textContent = "Estimated revenue: Error loading data.";
    }
});

// Close modal when the close button is clicked
closeModalButton.addEventListener("click", () => {
    modalContainer.style.display = "none"; // Hide the modal
});

// Prevent clicks inside the modal from closing it (if needed)
modalContainer.addEventListener("click", (event) => {
    if (event.target === modalContainer) {
        modalContainer.style.display = "none"; // Hide the modal when clicking outside of it
    }
});

document.getElementById("pendingPaymentsContainer").addEventListener("click", async () => {
            const content = document.getElementById("pendingPaymentsContent");
            const paymentsList = document.getElementById("pendingPaymentsList");

            if (content.style.display === "none" || content.style.display === "") {
                content.style.display = "block"; // Expand

                // Clear any existing data to prevent duplicates
                paymentsList.innerHTML = "<p>Loading...</p>";

                try {
                    // Fetch data from the API endpoint
                    const response = await fetch("https://stripebackend-production-0a48.up.railway.app/get-pending", {
                        method: "GET",
                        headers: {
                            "Content-Type": "application/json",
                            'Authorization': `Bearer ${state.token}`
                        }
                    });

                    if (!response.ok) {
                        throw new Error(`API Error: ${response.statusText}`);
                    }

                    const pendingPayments = await response.json();

                    // Handle case where no pending payments are returned
                    if (!pendingPayments || pendingPayments.length === 0) {
                        paymentsList.innerHTML = "<p>No pending payments found.</p>";
                        return;
                    }

                    // Render each pending payment
                    paymentsList.innerHTML = ""; // Clear loading message
                    pendingPayments.forEach((payment) => {

                                      // Convert 'created' to a readable date format
                    const createdDate = payment.created && payment.created._seconds
                    ? new Date(payment.created._seconds * 1000).toLocaleString() // Convert seconds to milliseconds
                    : "Unknown";
                        // Create a frame for each payment
                        const paymentItem = document.createElement("div");
                        paymentItem.className = "pendingPaymentItem";
                        paymentItem.innerHTML = `
                            <h4>${payment.title || "Untitled Payment"}</h4>
                            <p><strong>Name:</strong> ${payment.name || "Unknown"}</p>
                            <p><strong>Email:</strong> ${payment.email || "?"}</p>
                            <p><strong>Method:</strong> ${payment.method || "?"}</p>
                            <p><strong>Currency:</strong> ${payment.currency || "?"}</p>
                            <p><strong>Amount:</strong> ${payment.amount || "?"}</p>
                            <p><strong>Price:</strong> $${payment.total || "?"}</p>
                            <p><strong>PendingOrderId:</strong> ${payment.pendingorderid || "?"}</p>
                            <p><strong>Date:</strong> ${payment.date || "?"}</p>
                            <p><strong>Start Time:</strong> ${payment.start || "?"}</p>
                            <p><strong>End Time:</strong> ${payment.end || "?"}</p>
                            <p><strong>Description:</strong> ${payment.text || "?"}</p>
                            <p><strong>_id:</strong> ${payment._id || "?"}</p>
                            <p><strong>Eventid:</strong> ${payment.eventid || "?"}</p>
                            <p><strong>UserId:</strong> ${payment.userid || "?"}</p>
                            <p><strong>RequestedAt:</strong> ${createdDate}</p>
                        `;


          // Create a container div to hold the buttons
const ActionbuttonContainer = document.createElement("div");
ActionbuttonContainer.style.display = "flex";
ActionbuttonContainer.style.justifyContent = "flex-start"; // Distribute space between buttons
ActionbuttonContainer.style.gap = "10px"; // Adjust the space between buttons

          // Create 'Decline Order' button
          const declineOrderButton = document.createElement("button");
          declineOrderButton.textContent = "Decline Order";
          declineOrderButton.style.marginTop = "10px";
          declineOrderButton.style.backgroundColor = "#FF0000"
          declineOrderButton.style.color = "#fff"
          declineOrderButton.style.border = 'none'
          declineOrderButton.style.cursor = 'pointer'
          declineOrderButton.style.padding = '10px'
          declineOrderButton.style.borderRadius = '5px'
          declineOrderButton.addEventListener("click", async () => {
            try {
              const completeResponse = await fetch(
                "https://stripebackend-production-0a48.up.railway.app/decline-pending-order",
                {
                  method: "POST",
                  headers: {
                            "Content-Type": "application/json",
                            'Authorization': `Bearer ${state.token}`
                        },
                  body: JSON.stringify({ pendingorderid: payment.pendingorderid }),
                }
              );

              if (!completeResponse.ok) {
                throw new Error("Failed to decline order");
              }

              alert("Order declined!");
              // Optionally refresh the pending payments list
              
            } catch (error) {
              console.error("Error declining order:", error);
              alert("Failed to decline order. Please try again.");
            }
          });

          // Create 'Complete Order' button
          const completeOrderButton = document.createElement("button");
          completeOrderButton.textContent = "Complete Order";
          completeOrderButton.style.marginTop = "10px";
          completeOrderButton.style.backgroundColor = "#4CAF50"
          completeOrderButton.style.color = "#fff"
          completeOrderButton.style.border = 'none'
          completeOrderButton.style.cursor = 'pointer'
          completeOrderButton.style.padding = '10px'
          completeOrderButton.style.borderRadius = '5px'
          completeOrderButton.addEventListener("click", async () => {
            try {
              const completeResponse = await fetch(
                "https://stripebackend-production-0a48.up.railway.app/complete-pending-order",
                {
                  method: "POST",
                  headers: {
                            "Content-Type": "application/json",
                            'Authorization': `Bearer ${state.token}`
                        },
                  body: JSON.stringify({ pendingorderid: payment.pendingorderid }),
                }
              );

              if (!completeResponse.ok) {
                throw new Error("Failed to complete order");
              }

              alert("Order marked as complete!");
              // Optionally refresh the pending payments list
              
            } catch (error) {
              console.error("Error completing order:", error);
              alert("Failed to complete order. Please try again.");
            }
          });

          ActionbuttonContainer.appendChild(completeOrderButton);
          ActionbuttonContainer.appendChild(declineOrderButton);
          paymentItem.appendChild(ActionbuttonContainer);
                        paymentsList.appendChild(paymentItem);
                        console.log(payment.created)
                    });
                } catch (error) {
                    console.error("Error fetching pending payments:", error);
                    paymentsList.innerHTML = "<p>Error loading payments. Please try again later.</p>";
                }
            } else {
                content.style.display = "none"; // Collapse
            }
        });


    // Example initialization
    async function init() {
      try {
        const events = await fetchData('Events');
        setState({ local: events });
        //console.log(state.local)
        const payments = await fetchData('payments');
        
        // Create a map of payments by event
        const paymentsByEvent = {};
        payments.forEach(payment => {
          if (!paymentsByEvent[payment.eventid]) {
            paymentsByEvent[payment.eventid] = [];
          }
          paymentsByEvent[payment.eventid].push(payment);
        });

        // Render the event tree
        createEventTree(events,paymentsByEvent, document.getElementById('treeContainer'));
      } catch (error) {
        console.error('Error fetching data:', error);
      }
    }

    // Initialize the page
    //init();
  </script>
</body>
</html>
